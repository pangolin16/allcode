<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>Fronta práce</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
      integrity="sha512-z3gLpd7yknf1YoNbCzqRKc4qyor8gaKU1qmn+CShxbuBusANI9QpRohGBreCFkKxLhei6S9CQXFEbbKuqLg0DA=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <style>
body {
  font-family: "Segoe UI", Arial, sans-serif;
  background: #f6f8fa;
  margin: 0;
  padding: 24px;
}
.btn {
  background: #1976d2;
  color: #fff;
  border: none;
  border-radius: 6px;
  padding: 10px 18px;
  font-size: 18px;
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(25, 118, 210, 0.12);
  transition: background 0.2s, box-shadow 0.2s;
  margin-right: 10px;
}
.btn:hover {
  background: #115293;
  box-shadow: 0 4px 16px rgba(25, 118, 210, 0.18);
}
#tableContainer {
  margin-top: 24px;
  overflow-x: auto;
}
table {
  border-collapse: separate;
  border-spacing: 0;
  background: #fff;
  box-shadow: 0 2px 12px rgba(0,0,0,0.04);
  border-radius: 8px;
  overflow: hidden;
}
tr:nth-child(even) td {
  background: #f1f5f9;
}
tr:hover td {
  background: #e3f2fd;
  transition: background 0.2s;
}
td {
  border: 1px solid #eee;
  padding: 8px 14px;
  font-size: 20px;
  border-radius: 4px;
  transition: background 0.2s;
  vertical-align: middle;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.highlight-first-col {
  background: #fff59d !important;
  transition: background 0.2s;
}
.custom-context-menu {
  border-radius: 8px;
  box-shadow: 0 4px 32px rgba(0,0,0,0.18);
  animation: fadeIn 0.2s;
}
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px);}
  to { opacity: 1; transform: translateY(0);}
}
      .custom-context-menu {
          border-radius: 8px;
  box-shadow: 0 4px 32px rgba(0,0,0,0.18);
  animation: fadeIn 0.2s;

        position: absolute;
        background: #fff;
        border: 1px solid #ccc;
      
        z-index: 9999;
        min-width: 120px;
        padding: 0;
        margin: 0;
      }
      .custom-context-menu ul {
        list-style: none;
        margin: 0;
        padding: 0;
      }
      .custom-context-menu li {
        padding: 8px 16px;
        cursor: pointer;
        font-size: 15px;
        transition: background 0.2s;
      }
      .custom-context-menu li:hover {
        background: #e6e6fa;
      }

    </style>
</head>
<body>
    <button class="btn" id="btnSubmit"><i class="fa-solid fa-repeat"></i> Replace</button>
    <button class="btn" id="btnAppend"><i class="fa-solid fa-plus"></i> Append</button>


    <div id="tableContainer"></div>
 
    <button class="btn" id="btnProcess"><i class="fa-solid fa-clipboard"></i> Process Clipboard</button>
    <button class="btn" id="btnCopy"><i class="fa-solid fa-copy"></i> Copy Result to Clipboard</button>
    
    <div id="status"></div>
    <div id="output"></div>
		<div id="loading">
			<p>Loading application...</p>
			<p>(Are the JavaScript files missing?)</p>
			<p>(The JavaScript code needs to be compiled from the TypeScript code.)</p>
		</div>
		<form id="loaded" style="display:none" onsubmit="event.preventDefault();">
			<table>
				<tbody>
					<tr>
						<td><strong>Text string:</strong></td>
						<td><textarea placeholder="Enter your text to be put into the QR Code" id="text-input" style="width:30em; height:5em"></textarea></td>
					</tr>
					<tr>
						<td><strong>QR Code:</strong></td>
						<td>
							<canvas id="qrcode-canvas" style="padding:1em; background-color:#E8E8E8"></canvas>
							<svg id="qrcode-svg" style="width:30em; height:30em; padding:1em; background-color:#E8E8E8">
								<rect width="100%" height="100%" fill="#FFFFFF" stroke-width="0"></rect>
								<path d="" fill="#000000" stroke-width="0"></path>
							</svg>
						</td>
					</tr>
					<tr>
						<td><strong>Error correction:</strong></td>
						<td>
							<input type="radio" name="errcorlvl" id="errcorlvl-low" checked="checked"><label for="errcorlvl-low">Low</label>
							<input type="radio" name="errcorlvl" id="errcorlvl-medium"><label for="errcorlvl-medium">Medium</label>
							<input type="radio" name="errcorlvl" id="errcorlvl-quartile"><label for="errcorlvl-quartile">Quartile</label>
							<input type="radio" name="errcorlvl" id="errcorlvl-high"><label for="errcorlvl-high">High</label>
						</td>
					</tr>
					<tr>
						<td>Output format:</td>
						<td>
							<input type="radio" name="output-format" id="output-format-bitmap" checked="checked"><label for="output-format-bitmap">Bitmap</label>
							<input type="radio" name="output-format" id="output-format-vector"><label for="output-format-vector">Vector</label>
						</td>
					</tr>
					<tr>
						<td>Border:</td>
						<td><input type="number" value="4" min="0" max="100" step="1" id="border-input" style="width:4em"> modules</td>
					</tr>
					<tr id="scale-row">
						<td>Scale:</td>
						<td><input type="number" value="8" min="1" max="30" step="1" id="scale-input" style="width:4em"> pixels per module</td>
					</tr>
					<tr>
						<td>Colors:</td>
						<td>
							Light = <input type="text" value="#FFFFFF" id="light-color-input" style="width:6em">,
							dark = <input type="text" value="#000000" id="dark-color-input" style="width:6em">
						</td>
					</tr>
					<tr>
						<td>Version range:</td>
						<td>
							Minimum = <input type="number" value="1"  min="1" max="40" step="1" id="version-min-input" style="width:4em" oninput="app.handleVersionMinMax('min');">,
							maximum = <input type="number" value="40" min="1" max="40" step="1" id="version-max-input" style="width:4em" oninput="app.handleVersionMinMax('max');">
						</td>
					</tr>
					<tr>
						<td>Mask pattern:</td>
						<td><input type="number" value="-1" min="-1" max="7" step="1" id="mask-input" style="width:4em"> (−1 for automatic, 0 to 7 for manual)</td>
					</tr>
					<tr>
						<td>Boost ECC:</td>
						<td><input type="checkbox" checked="checked" id="boost-ecc-input"><label for="boost-ecc-input">Increase <abbr title="error-correcting code">ECC</abbr> level within same version</label></td>
					</tr>
					<tr>
						<td>Statistics:</td>
						<td id="statistics-output" style="white-space:pre"></td>
					</tr>
					<tr id="svg-xml-row">
						<td>SVG XML code:</td>
						<td>
							<textarea id="svg-xml-output" readonly="readonly" style="width:100%; max-width:50em; height:15em; font-family:monospace"></textarea>
						</td>
					</tr>
				</tbody>
			</table>
		</form>
<script>
        let processedResult = null;

        function parseTabSeparatedData(text) {
            const lines = text.split(/\r?\n/);
            const rows = [];
            let currentRow = [];
            let cellContent = '';
            let inQuotedCell = false;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                let j = 0;
                
                while (j < line.length) {
                    const char = line[j];
                    
                    if (!inQuotedCell && char === '\t') {
                        // End of cell
                        currentRow.push(cellContent);
                        cellContent = '';
                    } else if (char === '"') {
                        // Toggle quoted cell state
                        inQuotedCell = !inQuotedCell;
                    } else {
                        // Add character to current cell content
                        cellContent += char;
                    }
                    j++;
                }
                
                // Check if we're at the end of a row (not in a quoted cell)
                if (!inQuotedCell) {
                    // Add the last cell of the row
                    currentRow.push(cellContent);
                    rows.push(currentRow);
                    currentRow = [];
                    cellContent = '';
                } else {
                    // We're in a multi-line quoted cell, add a newline and continue
                    cellContent += '\n';
                }
            }
            
            // Add any remaining row if we ended in the middle of one
            if (currentRow.length > 0 || cellContent) {
                currentRow.push(cellContent);
                rows.push(currentRow);
            }
            
            return rows.filter(row => row.some(cell => cell.trim() !== ''));
        }

        function processClipboardData(clipboardText) {
            try {
                // Parse the tab-separated data properly handling multi-line cells
                const rows = parseTabSeparatedData(clipboardText);
                
                // Process each row: add empty column at start, keep first 3 columns and insert 22 empty columns between 2nd and 3rd
                const processedRows = rows.map(row => {
                    // Get first 3 columns (or empty strings if they don't exist)
                    const col1 = row[0] || '';
                    const col2 = row[1] || '';
                    const col3 = row[2] || '';
                    
                    // Create an array of 22 empty strings
                    const emptyColumns = Array(20).fill('');
                    
                    // Return array with an empty column at the start, then col1, col2, 22 empty columns, then col3
                    return ['', col1, col2, ...emptyColumns, col3];
                });
                
                return processedRows;
                
            } catch (error) {
                console.error('Error processing clipboard data:', error);
                return null;
            }
        }

        // Convert processed data back to tab-separated string
        function convertToTabSeparated(processedData) {
            return processedData.map(row => row.join('\t')).join('\n');
        }

        // Display functions
        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        function displayResult(data) {
            const output = document.getElementById('output');
            if (data && data.length > 0) {
                const tabSeparated = convertToTabSeparated(data);
                output.textContent = tabSeparated;
                showStatus(`Successfully processed ${data.length} rows. Result displayed below.`, 'success');
            } else {
                output.textContent = 'No data to display';
                showStatus('No valid data found to process.', 'error');
            }
        }

        // Main processing function
        async function processFromClipboard() {
            try {
                showStatus('Reading clipboard...', 'info');
                const clipboardText = await navigator.clipboard.readText();
                
                if (!clipboardText.trim()) {
                    showStatus('Clipboard is empty.', 'error');
                    return null;
                }
                
                const processedData = processClipboardData(clipboardText);
                
                if (processedData) {
                    processedResult = processedData;
                    displayResult(processedData);
                    console.log('Processed data:', processedData);
                    return processedData;
                } else {
                    showStatus('Failed to process clipboard data.', 'error');
                    return null;
                }
            } catch (err) {
                console.error('Failed to read clipboard:', err);
                showStatus('Failed to read clipboard. Make sure to grant clipboard permissions.', 'error');
                    return null;
                }
            }



        // Copy result to clipboard
        async function copyResultToClipboard() {
            if (!processedResult) {
                showStatus('No processed data to copy. Process some data first.', 'error');
                return;
            }
            
            try {
                const tabSeparated = convertToTabSeparated(processedResult);
                await navigator.clipboard.writeText(tabSeparated);
                showStatus('Result copied to clipboard successfully!', 'success');
            } catch (err) {
                console.error('Failed to copy to clipboard:', err);
                showStatus('Failed to copy to clipboard.', 'error');
            }
        }

        // Event listeners
        document.getElementById('btnProcess').addEventListener('click', processFromClipboard);
        document.getElementById('btnTest').addEventListener('click', testProcessClipboardData);
        document.getElementById('btnCopy').addEventListener('click', copyResultToClipboard);
    </script>


		<script type="application/javascript" src="qrcodegen.js"></script>
		<script type="application/javascript" src="qrcodegen-input-demo.js"></script>
</body>

<script>
// --- matData and matLookup ---
let matData = [
  ["M300015", "Pěna 23/10"],
  ["M300013", "Pěna 23/20"],
  ["M300014", "Pěna 23/30"],
  ["M300010", "Pěna 23/40"],
  ["M300011", "Pěna 23/50"],
  ["M300012", "Pěna 24/60"],
  ["M300057", "Pěna 28/70"],
  ["M300066", "Pěna 28/10"],
  ["M300024", "Pěna 35/20"],
  ["M300025", "Pěna 35/50"],
  ["M300086", "Pěna 65/40"],
  ["M300114", "Pěna 24/25"],
  ["M300022", "Pěna 35/30"],
  ["M102780", "2.31 BE"],
  ["M103226", "2.35 BE"],
  ["M105367", "2.41 BE"],
    ["M107881", "2.41 BE"],
  ["M101447", "2.31 BE"],
  ["M107869", "2.31 BE"],
  ["M104281", "3.90 AAC"],
  ["M103469", "3.91 AAC"],
  ["M104730", "3.92 AAC"],
   ["M107880", "3.92 AAC"],
  ["M102476", "3.95 AAC"],
    ["M101450", "3.95 AAC"],
  ["M104188", "3.96 AAC"],
  ["M200009", "CP 2mm"],
  ["M200043", "CP 2,5mm"],
  ["M200034", "CP 3mm"],
  ["M200001", "CP 3,5mm"],
  ["M200004", "CP 5mm"],
  ["M200014", "CP 5mm"],
  ["M102112", "2.03 BC"],
   ["M107877", "2.03 BC"],
  ["M101446", "2.30 BC"],
  ["M106269", "2.30 BC"],
  ["M107862", "2.30 BC"],
  ["M100197", "2.31 BC"],
  ["M100446", "2.31 BC"],
  ["M102338", "2.31 BC"],
    ["M107860", "2.31 BC"],
  ["M103231", "2.35 BC N2"],
  ["M107883", "2.35 BC N2"],
  ["M101765", "2.40 BC N2"],
  ["M100554", "2.40 BC N2"],
  ["M101538", "2.41 BC"],
   ["M107873", "2.41 BC"],
  ["M101455", "2.50 BC N2"],
  ["M107868", "2.50 BC N2"],
  ["M101539", "2.51 BC"],
    ["M107875", "2.51 BC"],
  ["M103225", "2.60 BC N2"],
  ["M103223", "2.70 BC N2"],
  ["M101448", "2.71 BC"],
  ["M102036", "2.71 BC"],
   ["M107863", "2.71 BC"],
  ["M101989", "2.90 BC"],
  ["M105705", "2.90 BC"],
  ["M107876", "2.90 BC"],
  ["M101990", "2.91 BC"],
  ["M101449", "2.91 BC"],
    ["M107864", "2.91 BC"],
  ["M102035", "2.91 AC"],
  ["M107879", "2.91 AC"],
  ["M103945", "2.92 AC"],
  ["M101588", "1.20 B"],
    ["M101441", "1.20 B"],
      ["M107861", "1.20 B"],
  ["M103229", "1.25 B"],
   ["M107871", "1.25 B"],
  ["M100187", "1.30 B"],
  ["M101454", "1.30 B"],
  ["M107867", "1.30 B"],
  ["M100062", "1,37 B"],
    ["M101442", "1,37 B"],
      ["M107870", "1,37 B"],
  ["M102964", "1.31 B"],
   ["M107874", "1.31 B"],
  ["M102425", "1.41 B"],
  ["M101443", "1.41 B"],
  ["M107665", "1.41 B N1"],
 ["M107859", "1.41 B"],
 ["M107878", "1.41 B N1"],
  ["M103232", "1.20 C"],
  ["M101764", "1.30 C"],
  ["M107872", "1.30 C"],
  ["M101444", "1.31 C"],
  ["M102086", "1.31 C"],
  ["M107866", "1.31 C"],
  ["M100198", "1.41 C"],
  ["M101445", "1.41 C"],
  ["M107865", "1.41 C"],
  ["M100012", "1.21 E"],
  ["M102364", "1.25 E"], 
   ["M100013", "1.25 E"]
];

let valueToCodes = {};
matData.forEach(([code, value]) => {
  if (!valueToCodes[value]) valueToCodes[value] = [];
  valueToCodes[value].push(code);
});

let matLookup = {};
matData.forEach(([code, value]) => {
  matLookup[code] = value;
});

// Global variable to store current table data
let currentTableData = [];
let originalRowCount = 0;

function getColor(index) {
  const palette = [
    "#c9f1fc", "#d4f8c4", "#ffe0ac", "#f9c6c7", "#d6c6f9", "#ffc6e0",
    "#c6ffe0", "#f6f7d7", "#e6e6fa", "#cef6e3", "#ffd6d6", "#d6fffa"
  ];
  if (index < palette.length) return palette[index];
  return `hsl(${(index * 47) % 360}, 70%, 80%)`;
}

function removeContextMenu() {
  const menu = document.querySelector('.custom-context-menu');
  if (menu) menu.remove();
}

function removeDuplicateRows(tableData) {
  const uniqueRows = [];
  const seenRowSignatures = new Set();
  
  tableData.forEach(row => {
    const rowSignature = JSON.stringify(row);
    if (!seenRowSignatures.has(rowSignature)) {
      seenRowSignatures.add(rowSignature);
      uniqueRows.push(row);
    }
  });
  
  return uniqueRows;
}

function processTableData(rawTableData) {
  // Replace 2nd column cell value if found in matLookup
  rawTableData.forEach(rowData => {
    if (rowData.length > 1) {
      const lookupValue = matLookup[rowData[1]];
      if (lookupValue !== undefined) {
        rowData[1] = lookupValue;
      }
    }
    
    // Convert 3rd column date format from DD.MM.YY to DD.MM.
    if (rowData.length > 2 && rowData[2]) {
      // Match DD.MM.YY format (where YY can be 2 or 4 digits)
      const dateMatch = rowData[2].match(/^(\d{1,2})\.(\d{1,2})\.(\d{2,4})$/);
      if (dateMatch) {
        const [, day, month] = dateMatch;
        rowData[2] = `${day}.${month}.`;
      }
    }
  });
  
  // Remove duplicate rows
  return removeDuplicateRows(rawTableData);
}

function renderTable(tableData) {
  // Count occurrences of each value in the 2nd column
  const valueCounts = {};
  tableData.forEach(row => {
    if (row.length > 1 && row[1]) {
      valueCounts[row[1]] = (valueCounts[row[1]] || 0) + 1;
    }
  });

  const frequentValues = Object.keys(valueCounts).filter(val => valueCounts[val] > 1);
  const valueColorMap = {};
  frequentValues.forEach((val, i) => {
    valueColorMap[val] = getColor(i);
  });

  // Create table without header, and only columns 0, 1, 21
  const table = document.createElement('table');
  table.style.borderCollapse = 'collapse';

  tableData.forEach((rowData, rowIdx) => {
    const tr = document.createElement('tr');
    // Add columns 0, 1, and 2 (which correspond to orig 0, 1, 21)
    rowData.forEach((cellData, colIdx) => {
      const td = document.createElement('td');
      // Remove line breaks from cell data and take only the first line
      const cleanedData = cellData.split(/\r?\n/)[0];
      td.textContent = cleanedData;
      td.style.border = '1px solid #ccc';
      td.style.padding = '4px 8px';
      // Only color 2nd column if its value occurs more than once
      if (colIdx === 1 && valueColorMap[cleanedData]) {
        td.style.background = valueColorMap[cleanedData];
      }
      // Context menu for 2nd column
      if (colIdx === 1) {
        td.addEventListener('contextmenu', function(e) {
          e.preventDefault();
          removeContextMenu();
          const codes = valueToCodes[cleanedData];
          if (!codes || codes.length === 0) return;
          const menu = document.createElement('div');
          menu.className = 'custom-context-menu';
          const ul = document.createElement('ul');
          codes.forEach(code => {
            const li = document.createElement('li');
            li.textContent = code;
            ul.appendChild(li);
          });
          menu.appendChild(ul);
          document.body.appendChild(menu);
          menu.style.left = `${e.pageX}px`;
          menu.style.top = `${e.pageY}px`;
        });
      }
      // Highlight first column cell on click
      if (colIdx === 0) {
        td.addEventListener('click', function() {
          td.classList.toggle('highlight-first-col');
        });
      }
      tr.appendChild(td);
    });
    
    // Add scissors emoji cell for original rows only
    const scissorsTd = document.createElement('td');
    if (rowIdx < originalRowCount) {
      scissorsTd.textContent = '✂️';
    }
    scissorsTd.style.border = '1px solid #ccc';
    scissorsTd.style.padding = '4px 8px';
    scissorsTd.style.textAlign = 'center';
    tr.appendChild(scissorsTd);
    
    table.appendChild(tr);
  });

  const container = document.getElementById('tableContainer');
  container.innerHTML = '';
  container.appendChild(table);
}

function parseTabSeparatedData(text) {
  const lines = text.split(/\r?\n/);
  const rows = [];
  let currentRow = [];
  let cellContent = '';
  let inQuotedCell = false;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    let j = 0;
    
    while (j < line.length) {
      const char = line[j];
      
      if (!inQuotedCell && char === '\t') {
        // End of cell
        currentRow.push(cellContent);
        cellContent = '';
      } else if (char === '"') {
        // Toggle quoted cell state
        inQuotedCell = !inQuotedCell;
      } else {
        // Add character to current cell content
        cellContent += char;
      }
      j++;
    }
    
    // Check if we're at the end of a row (not in a quoted cell)
    if (!inQuotedCell) {
      // Add the last cell of the row
      currentRow.push(cellContent);
      rows.push(currentRow);
      currentRow = [];
      cellContent = '';
    } else {
      // We're in a multi-line quoted cell, add a newline and continue
      cellContent += '\n';
    }
  }
  
  // Add any remaining row if we ended in the middle of one
  if (currentRow.length > 0 || cellContent) {
    currentRow.push(cellContent);
    rows.push(currentRow);
  }
  
  return rows.filter(row => row.some(cell => cell.trim() !== ''));
}

async function readClipboardAndProcess() {
  try {
    const text = await navigator.clipboard.readText();
    
    // Parse the tab-separated data properly handling multi-line cells
    const rows = parseTabSeparatedData(text);

    // Take columns [0], [1], and [21] only
const tableData = rows.map(row => {
  const col0 = row[1] !== undefined ? row[1] : '';
  const col1 = row[2] !== undefined ? row[2] : '';
  const col21 = row[23] !== undefined ? row[23] : '';
  return [col0, col1, col21];
});


    return processTableData(tableData);
  } catch (err) {
    alert('Failed to read clipboard. Make sure to grant clipboard permissions.');
    console.error(err);
    return null;
  }
}

document.addEventListener('click', removeContextMenu);
document.addEventListener('scroll', removeContextMenu);

document.getElementById('btnSubmit').addEventListener('click', async () => {
  const tableData = await readClipboardAndProcess();
  if (tableData) {
    const originalCount = tableData.length;
    currentTableData = tableData; // processTableData already removes duplicates
    originalRowCount = currentTableData.length; // Track original rows after deduplication
    
    // Show info about filtered duplicates if any were removed
    const duplicateCount = originalCount - currentTableData.length;
    if (duplicateCount > 0) {
      alert(`${duplicateCount} duplicate row(s) were removed. Showing ${currentTableData.length} unique row(s).`);
    }
    
    renderTable(currentTableData);
  }
});

document.getElementById('btnAppend').addEventListener('click', async () => {
  const newTableData = await readClipboardAndProcess();
  if (newTableData) {
    // Create a set of existing row signatures for fast lookup
    const existingRowSignatures = new Set(
      currentTableData.map(row => JSON.stringify(row))
    );
    
    // Filter out duplicate rows
    const uniqueNewRows = newTableData.filter(row => {
      const rowSignature = JSON.stringify(row);
      return !existingRowSignatures.has(rowSignature);
    });
    
    // Show info about filtered rows
    const duplicateCount = newTableData.length - uniqueNewRows.length;
    if (duplicateCount > 0) {
      alert(`${duplicateCount} duplicate row(s) were filtered out. Adding ${uniqueNewRows.length} new row(s).`);
    }
    
    // Append only unique new data to existing data
    currentTableData = currentTableData.concat(uniqueNewRows);
    renderTable(currentTableData);
  }
});
</script>

</html>