<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fronta prÃ¡ce</title>
    <script src="./jsQR.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <style>
body {
  font-family: "Segoe UI", Arial, sans-serif;
  background: #f6f8fa;
  margin: 0;
  padding: 24px;
}
.btn {
  background: #1976d2;
  color: #fff;
  border: none;
  border-radius: 6px;
  padding: 10px 18px;
  font-size: 18px;
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(25, 118, 210, 0.12);
  transition: background 0.2s, box-shadow 0.2s;
  margin-right: 10px;
}
.btn:hover {
  background: #115293;
  box-shadow: 0 4px 16px rgba(25, 118, 210, 0.18);
}
#tableContainer {
  margin-top: 16px;
  overflow-x: auto;
  max-width: 100vw;
}
table {
  width: 100%;
  border-collapse: collapse;
  background: #fff;
}
tr {
  border-bottom: 1px solid #eee;
}
td {
  font-size: 18px;
  padding: 12px 8px;
  border: none;
  vertical-align: middle;
  word-break: break-word;
  white-space: pre-line;
  max-width: 160px;
  text-overflow: ellipsis;
}
tr:nth-child(even) td {
  background: #f9f9f9;
}
tr:hover td {
  background: #e3f2fd;
  transition: background 0.2s;
}
table, td, tr {
  border-radius: 0;
  box-shadow: none;
}
.highlight-first-col {
  background: #fff59d !important;
  transition: background 0.2s;
}
.comment-cell {
  background: #ffffcc !important;
  font-style: italic;
  color: #444;
  min-width: 80px;
}
.custom-context-menu {
  border-radius: 8px;
  box-shadow: 0 4px 32px rgba(0,0,0,0.18);
  animation: fadeIn 0.2s;
}
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px);}
  to { opacity: 1; transform: translateY(0);}
}
      .custom-context-menu {
          border-radius: 8px;
  box-shadow: 0 4px 32px rgba(0,0,0,0.18);
  animation: fadeIn 0.2s;

        position: absolute;
        background: #fff;
        border: 1px solid #ccc;
        z-index: 9999;
        min-width: 120px;
        padding: 0;
        margin: 0;
      }
      .custom-context-menu ul {
        list-style: none;
        margin: 0;
        padding: 0;
      }
      .custom-context-menu li {
        padding: 8px 16px;
        cursor: pointer;
        font-size: 15px;
        transition: background 0.2s;
      }
      .custom-context-menu li:hover {
        background: #e6e6fa;
      }
    </style>
</head>
<body>
   <div id="loadingMessage">ðŸŽ¥ Unable to access video stream (please make sure you have a webcam enabled)</div>
  <canvas id="canvas" hidden></canvas>
 <div id="output" hidden>
  <input id="outputMessage" value="No QR code detected.">
  <div hidden>
    <b>Data:</b>
    <pre id="outputData"></pre>
  </div>
</div>
</body>
<script>
  var video = document.createElement("video");
  var canvasElement = document.getElementById("canvas");
  var canvas = canvasElement.getContext("2d");
  var loadingMessage = document.getElementById("loadingMessage");
  var outputContainer = document.getElementById("output");
  var outputMessage = document.getElementById("outputMessage");
  var outputData = document.getElementById("outputData");

  let saved = false;

  function drawLine(begin, end, color) {
    canvas.beginPath();
    canvas.moveTo(begin.x, begin.y);
    canvas.lineTo(end.x, end.y);
    canvas.lineWidth = 4;
    canvas.strokeStyle = color;
    canvas.stroke();
  }

  navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } }).then(function(stream) {
    video.srcObject = stream;
    video.setAttribute("playsinline", true);
    video.play();
    requestAnimationFrame(tick);
  });

  function tick() {
    loadingMessage.innerText = "âŒ› Loading video...";
    if (video.readyState === video.HAVE_ENOUGH_DATA) {
      loadingMessage.hidden = true;
      canvasElement.hidden = false;
      outputContainer.hidden = false;
      // --- Responsive canvas size: 80% of viewport ---
      const maxWidth = window.innerWidth * 0.8;
      const maxHeight = window.innerHeight * 0.8;
      let aspect = video.videoWidth / video.videoHeight;
      let width = maxWidth;
      let height = maxWidth / aspect;
      if (height > maxHeight) {
        height = maxHeight;
        width = maxHeight * aspect;
      }
      canvasElement.width = width;
      canvasElement.height = height;
      canvas.drawImage(video, 0, 0, canvasElement.width, canvasElement.height);
      var imageData = canvas.getImageData(0, 0, canvasElement.width, canvasElement.height);
      var code = jsQR(imageData.data, imageData.width, imageData.height, {
        inversionAttempts: "dontInvert",
      });

      if (code) {
        drawLine(code.location.topLeftCorner, code.location.topRightCorner, "#FF3B58");
        drawLine(code.location.topRightCorner, code.location.bottomRightCorner, "#FF3B58");
        drawLine(code.location.bottomRightCorner, code.location.bottomLeftCorner, "#FF3B58");
        drawLine(code.location.bottomLeftCorner, code.location.topLeftCorner, "#FF3B58");
        outputMessage.hidden = true;
        outputData.parentElement.hidden = false;
        outputData.textContent = code.data;

        // Save once and show new input field
        if (!saved) {
          localStorage.setItem("qrData", code.data);
          document.body.innerHTML = ""; // clear everything
          createUIElements();
          saved = true;
        }
      }
    }
    requestAnimationFrame(tick);
  }

  // Fix: create input and tableContainer after clearing body
  function createUIElements() {
    // Create the textarea element (instead of input)
    const textArea = document.createElement('textarea');
    textArea.id = "triggerInput";
    textArea.style.padding = "10px";
    textArea.style.fontSize = "16px";
    textArea.style.width = "300px";
    textArea.style.height = "100px"; // You can adjust height as needed
    textArea.value = localStorage.getItem("qrData") || "";
    textArea.hidden = true; // Hide the input field

    // Create the table container
    const tableContainer = document.createElement('div');
    tableContainer.id = "tableContainer";
    tableContainer.style.marginTop = "24px";
    tableContainer.style.overflowX = "auto";

    // Add to document body
    document.body.appendChild(textArea);
    document.body.appendChild(tableContainer);

    // --- Use the value in textarea as the data source ---
    updateTableFromInput();

    // If you want table to update on further edits, you can keep the handler below:
    textArea.addEventListener('input', updateTableFromInput);
  }

  function updateTableFromInput() {
    const inputValue = document.getElementById('triggerInput').value;
    const rows = inputValue.split('\n').map(line => line.split('\t'));
    // Take columns [1], [2], [23] (as per previous code)
    const tableData = rows.map(row => {
      const col0 = row[1] !== undefined ? row[1] : '';
      const col1 = row[2] !== undefined ? row[2] : '';
      const col21 = row[23] !== undefined ? row[23] : '';
      return [col0, col1, col21];
    });
    const processedData = processTableData(tableData);
    currentTableData = processedData;
    originalRowCount = processedData.length;
    if (!Array.isArray(rowComments) || rowComments.length !== processedData.length) {
      // Reset or resize comment array if needed
      rowComments = new Array(processedData.length).fill("");
    }
    renderTable(processedData);
  }

  // --- Comment and swipe logic additions below ---

  // For comment storage
  let rowComments = [];

  // --- matData, valueToCodes, matLookup ---
  let matData = [];
  let valueToCodes = {};
  matData.forEach(([code, value]) => {
    if (!valueToCodes[value]) valueToCodes[value] = [];
    valueToCodes[value].push(code);
  });
  let matLookup = {};
  matData.forEach(([code, value]) => {
    matLookup[code] = value;
  });

  // Global variable to store current table data
  let currentTableData = [];
  let originalRowCount = 0;

  function getColor(index) {
    const palette = [
      "#c9f1fc", "#d4f8c4", "#ffe0ac", "#f9c6c7", "#d6c6f9", "#ffc6e0",
      "#c6ffe0", "#f6f7d7", "#e6e6fa", "#cef6e3", "#ffd6d6", "#d6fffa"
    ];
    if (index < palette.length) return palette[index];
    return `hsl(${(index * 47) % 360}, 70%, 80%)`;
  }

  function removeContextMenu() {
    const menu = document.querySelector('.custom-context-menu');
    if (menu) menu.remove();
  }

  function removeDuplicateRows(tableData) {
    const uniqueRows = [];
    const seenRowSignatures = new Set();
    tableData.forEach(row => {
      const rowSignature = JSON.stringify(row);
      if (!seenRowSignatures.has(rowSignature)) {
        seenRowSignatures.add(rowSignature);
        uniqueRows.push(row);
      }
    });
    return uniqueRows;
  }

  function processTableData(rawTableData) {
    rawTableData.forEach(rowData => {
      if (rowData.length > 1) {
        const lookupValue = matLookup[rowData[1]];
        if (lookupValue !== undefined) {
          rowData[1] = lookupValue;
        }
      }
      if (rowData.length > 2 && rowData[2]) {
        const dateMatch = rowData[2].match(/^(\d{1,2})\.(\d{1,2})\.(\d{2,4})$/);
        if (dateMatch) {
          const [, day, month] = dateMatch;
          rowData[2] = `${day}.${month}.`;
        }
      }
    });
    return removeDuplicateRows(rawTableData);
  }

  function renderTable(tableData) {
    // Update rowComments length if needed
    if (!Array.isArray(rowComments) || rowComments.length !== tableData.length) {
      rowComments = new Array(tableData.length).fill("");
    }
    // Count occurrences of each value in the 2nd column
    const valueCounts = {};
    tableData.forEach(row => {
      if (row.length > 1 && row[1]) {
        valueCounts[row[1]] = (valueCounts[row[1]] || 0) + 1;
      }
    });

    const frequentValues = Object.keys(valueCounts).filter(val => valueCounts[val] > 1);
    const valueColorMap = {};
    frequentValues.forEach((val, i) => {
      valueColorMap[val] = getColor(i);
    });

    const table = document.createElement('table');
    table.style.borderCollapse = 'collapse';

    tableData.forEach((rowData, rowIdx) => {
      const tr = document.createElement('tr');
      rowData.forEach((cellData, colIdx) => {
        const td = document.createElement('td');
        const cleanedData = (cellData || '').split(/\r?\n/)[0];
        td.textContent = cleanedData;
        td.style.border = '1px solid #ccc';
        td.style.padding = '4px 8px';
        if (colIdx === 1 && valueColorMap[cleanedData]) {
          td.style.background = valueColorMap[cleanedData];
        }
        if (colIdx === 1) {
          td.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            removeContextMenu();
            const codes = valueToCodes[cleanedData];
            if (!codes || codes.length === 0) return;
            const menu = document.createElement('div');
            menu.className = 'custom-context-menu';
            const ul = document.createElement('ul');
            codes.forEach(code => {
              const li = document.createElement('li');
              li.textContent = code;
              ul.appendChild(li);
            });
            menu.appendChild(ul);
            document.body.appendChild(menu);
            menu.style.left = `${e.pageX}px`;
            menu.style.top = `${e.pageY}px`;
          });
        }
        if (colIdx === 0) {
          td.addEventListener('click', function() {
            td.classList.toggle('highlight-first-col');
          });
        }
        tr.appendChild(td);
      });

      // --- COMMENT CELL ---
      // Render the comment cell, if any
      const comment = rowComments[rowIdx] || "";
      const commentTd = document.createElement('td');
      commentTd.className = "comment-cell";
      commentTd.textContent = comment;
      commentTd.style.border = '1px solid #ccc';
      commentTd.style.padding = '4px 8px';
      tr.appendChild(commentTd);

      // Add swipe gesture logic for comment per row
      addSwipeHandlers(tr, rowIdx);

      table.appendChild(tr);
    });

    const container = document.getElementById('tableContainer');
    container.innerHTML = '';
    container.appendChild(table);
  }

  // Swipe handler: right = add comment, left = remove comment or row
  function addSwipeHandlers(rowElement, rowIdx) {
    let touchStartX = 0, touchEndX = 0;
    rowElement.addEventListener('touchstart', (e) => {
      touchStartX = e.changedTouches[0].clientX;
    });
    rowElement.addEventListener('touchend', (e) => {
      touchEndX = e.changedTouches[0].clientX;
      const diffX = touchEndX - touchStartX;
      // Swipe right: add/replace comment
      if (diffX > 50) {
        const currentComment = rowComments[rowIdx] || "";
        const newComment = prompt("Add a comment to this row:", currentComment);
        if (newComment !== null) {
          rowComments[rowIdx] = newComment.trim();
          renderTable(currentTableData);
        }
      }
      // Swipe left: remove comment or remove row
      else if (diffX < -50) {
        if (rowComments[rowIdx]) {
          // Remove only comment
          rowComments[rowIdx] = "";
          renderTable(currentTableData);
        } else {
          // Remove the row entirely (and keep comments array in sync)
          currentTableData.splice(rowIdx, 1);
          rowComments.splice(rowIdx, 1);
          renderTable(currentTableData);
        }
      }
    });
  }

  function parseTabSeparatedData(text) {
    const lines = text.split(/\r?\n/);
    const rows = [];
    let currentRow = [];
    let cellContent = '';
    let inQuotedCell = false;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      let j = 0;
      while (j < line.length) {
        const char = line[j];
        if (!inQuotedCell && char === '\t') {
          currentRow.push(cellContent);
          cellContent = '';
        } else if (char === '"') {
          inQuotedCell = !inQuotedCell;
        } else {
          cellContent += char;
        }
        j++;
      }
      if (!inQuotedCell) {
        currentRow.push(cellContent);
        rows.push(currentRow);
        currentRow = [];
        cellContent = '';
      } else {
        cellContent += '\n';
      }
    }
    if (currentRow.length > 0 || cellContent) {
      currentRow.push(cellContent);
      rows.push(currentRow);
    }
    return rows.filter(row => row.some(cell => cell.trim() !== ''));
  }

  async function readClipboardAndProcess() {
    try {
      const text = await navigator.clipboard.readText();
      const rows = parseTabSeparatedData(text);
      const tableData = rows.map(row => {
        const col0 = row[1] !== undefined ? row[1] : '';
        const col1 = row[2] !== undefined ? row[2] : '';
        const col21 = row[23] !== undefined ? row[23] : '';
        return [col0, col1, col21];
      });
      return processTableData(tableData);
    } catch (err) {
      alert('Failed to read clipboard. Make sure to grant clipboard permissions.');
      console.error(err);
      return null;
    }
  }

  document.addEventListener('click', removeContextMenu);
  document.addEventListener('scroll', removeContextMenu);

  // --- Replace logic triggered on input field change ---
  // (not used in mobile QR, but left for completeness)
  if (document.getElementById('triggerInput')) {
    document.getElementById('triggerInput').addEventListener('input', async () => {
      const tableData = await readClipboardAndProcess();
      if (tableData) {
        const originalCount = tableData.length;
        currentTableData = tableData;
        originalRowCount = currentTableData.length;
        rowComments = new Array(currentTableData.length).fill(""); // reset comments array
        const duplicateCount = originalCount - currentTableData.length;
        if (duplicateCount > 0) {
          alert(`${duplicateCount} duplicate row(s) were removed. Showing ${currentTableData.length} unique row(s).`);
        }
        renderTable(currentTableData);
      }
    });
  }
</script>
</html>