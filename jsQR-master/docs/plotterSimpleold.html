<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fronta prÃ¡ce</title>
    <script src="./jsQR.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lzma@2.3.2/src/lzma_worker.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
      integrity="sha512-z3gLpd7yknf1YoNbCzqRKc4qyor8gaKU1qmn+CShxbuBusANI9QpRohGBreCFkKxLhei6S9CQXFEbbKuqLg0DA=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <style>
body {
  font-family: "Segoe UI", Arial, sans-serif;
  background: #f6f8fa;
  margin: 0;
  padding: 24px;
}
.btn {
  background: #1976d2;
  color: #fff;
  border: none;
  border-radius: 6px;
  padding: 10px 18px;
  font-size: 18px;
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(25, 118, 210, 0.12);
  transition: background 0.2s, box-shadow 0.2s;
  margin-right: 10px;
}
.btn:hover {
  background: #115293;
  box-shadow: 0 4px 16px rgba(25, 118, 210, 0.18);
}
#tableContainer {
  margin-top: 16px;
  overflow-x: auto;
  max-width: 100vw;
}
table {
  width: 100%;
  border-collapse: collapse;
  background: #fff;
}

tr {
  border-bottom: 1px solid #eee;
}

td {
  font-size: 18px;
  padding: 12px 8px;
  border: none;
  vertical-align: middle;
  word-break: break-word;
  white-space: pre-line;
  max-width: 160px;
  text-overflow: ellipsis;
}

tr:nth-child(even) td {
  background: #f9f9f9;
}
tr:hover td {
  background: #e3f2fd;
  transition: background 0.2s;
}

table, td, tr {
  border-radius: 0;
  box-shadow: none;
}
.highlight-first-col {
  background: #fff59d !important;
  transition: background 0.2s;
}
.custom-context-menu {
  border-radius: 8px;
  box-shadow: 0 4px 32px rgba(0,0,0,0.18);
  animation: fadeIn 0.2s;
  position: absolute;
  background: #fff;
  border: 1px solid #ccc;
  z-index: 9999;
  min-width: 120px;
  padding: 0;
  margin: 0;
}
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px);}
  to { opacity: 1; transform: translateY(0);}
}
.custom-context-menu ul {
  list-style: none;
  margin: 0;
  padding: 0;
}
.custom-context-menu li {
  padding: 8px 16px;
  cursor: pointer;
  font-size: 15px;
  transition: background 0.2s;
}
.custom-context-menu li:hover {
  background: #e6e6fa;
}
.selected-row {
  background-color: #ffeb3b !important;
  outline: 2px solid #fbc02d;
}
.selected-row td {
  background-color: #ffeb3b !important;
}
    </style>
</head>
<body>
   <div id="loadingMessage">ðŸŽ¥ Unable to access video stream (please make sure you have a webcam enabled)</div>
  <canvas id="canvas" hidden></canvas>
 <div id="output" hidden>
  <input id="outputMessage">No QR code detected.</input>
  <div hidden>
    <b>Data:</b>
    <pre id="outputData"></pre>
  </div>
</div>
</body>

<script>
  var video = document.createElement("video");
  var canvasElement = document.getElementById("canvas");
  var canvas = canvasElement.getContext("2d");
  var loadingMessage = document.getElementById("loadingMessage");
  var outputContainer = document.getElementById("output");
  var outputMessage = document.getElementById("outputMessage");
  var outputData = document.getElementById("outputData");

  let saved = false;

  function drawLine(begin, end, color) {
    canvas.beginPath();
    canvas.moveTo(begin.x, begin.y);
    canvas.lineTo(end.x, end.y);
    canvas.lineWidth = 4;
    canvas.strokeStyle = color;
    canvas.stroke();
  }

  navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } }).then(function(stream) {
    video.srcObject = stream;
    video.setAttribute("playsinline", true);
    video.play();
    requestAnimationFrame(tick);
  });

  function tick() {
    loadingMessage.innerText = "âŒ› Loading video...";
    if (video.readyState === video.HAVE_ENOUGH_DATA) {
      loadingMessage.hidden = true;
      canvasElement.hidden = false;
      outputContainer.hidden = false;

    const maxWidth = window.innerWidth * 0.8;
    const maxHeight = window.innerHeight * 0.8;

    let aspect = video.videoWidth / video.videoHeight;
    let width = maxWidth;
    let height = maxWidth / aspect;
    if (height > maxHeight) {
      height = maxHeight;
      width = maxHeight * aspect;
    }

    canvasElement.width = width;
    canvasElement.height = height;
      canvas.drawImage(video, 0, 0, canvasElement.width, canvasElement.height);
      var imageData = canvas.getImageData(0, 0, canvasElement.width, canvasElement.height);
      var code = jsQR(imageData.data, imageData.width, imageData.height, {
        inversionAttempts: "dontInvert",
      });

      if (code) {
        drawLine(code.location.topLeftCorner, code.location.topRightCorner, "#FF3B58");
        drawLine(code.location.topRightCorner, code.location.bottomRightCorner, "#FF3B58");
        drawLine(code.location.bottomRightCorner, code.location.bottomLeftCorner, "#FF3B58");
        drawLine(code.location.bottomLeftCorner, code.location.topLeftCorner, "#FF3B58");
        outputMessage.hidden = true;
        outputData.parentElement.hidden = false;
        outputData.textContent = code.data;

        if (!saved) {
          saved = true;
          // Decompress the QR data before using it
          decompressAndCreateUI(code.data);
        }
      }
    }
    requestAnimationFrame(tick);
  }

  // Decompression function
  function base64ToUint8(base64) {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
  }

  function decompressAndCreateUI(scannedBase64) {
    const compressedBytes = base64ToUint8(scannedBase64);
    LZMA.decompress(Array.from(compressedBytes), function(decompressed) {
      let originalText = "";
      if (Array.isArray(decompressed)) {
        if (decompressed.every(n => typeof n === "number" && n >= 0 && n <= 255)) {
          const decoder = new TextDecoder();
          originalText = decoder.decode(Uint8Array.from(decompressed));
        } else {
          originalText = String.fromCharCode(...decompressed);
        }
      } else if (typeof decompressed === "string") {
        originalText = decompressed;
      } else {
        originalText = "[Unknown decompressed type]";
      }
      
      // Convert multiple spaces to tabs for proper formatting
      const formattedText = originalText.replace(/\s{2,}/g, '\t');
      
      // Clear everything and create UI with decompressed data
      document.body.innerHTML = "";
      createUIElements(formattedText);
    });
  }

  function createUIElements(decompressedData) {
    const textArea = document.createElement('textarea');
    textArea.id = "triggerInput";
    textArea.style.padding = "10px";
    textArea.style.fontSize = "16px";
    textArea.style.width = "300px";
    textArea.style.height = "100px";
    textArea.value = decompressedData;
    textArea.hidden = true;

    const tableContainer = document.createElement('div');
    tableContainer.id = "tableContainer";
    tableContainer.style.marginTop = "24px";
    tableContainer.style.overflowX = "auto";

    const rawDataContainer = document.createElement('div');
    rawDataContainer.id = "rawDataContainer";
    rawDataContainer.style.marginTop = "24px";
    rawDataContainer.style.padding = "10px";
    rawDataContainer.style.background = "#fff";
    rawDataContainer.style.border = "1px solid #ccc";
    rawDataContainer.style.borderRadius = "4px";

    const rawDataTitle = document.createElement('h3');
    rawDataTitle.textContent = "Raw Data:";
    rawDataTitle.style.marginTop = "0";

    const rawDataPre = document.createElement('pre');
    rawDataPre.id = "rawDataPre";
    rawDataPre.style.whiteSpace = "pre-wrap";
    rawDataPre.style.wordBreak = "break-all";
    rawDataPre.style.fontSize = "14px";
    rawDataPre.style.fontFamily = "monospace";
    rawDataPre.textContent = decompressedData;

    rawDataContainer.appendChild(rawDataTitle);
    rawDataContainer.appendChild(rawDataPre);

    document.body.appendChild(textArea);
    document.body.appendChild(tableContainer);
    document.body.appendChild(rawDataContainer);

    updateTableFromInput();
  }

function updateTableFromInput() {
  const inputValue = document.getElementById('triggerInput').value;
  
  // Split by tabs (now that we've converted spaces to tabs)
  const items = inputValue.split('\t').filter(item => item.trim());
  
  // Group every 3 items into a row (col1, col2, date)
  const tableData = [];
  for (let i = 0; i < items.length; i += 3) {
    if (i + 2 < items.length) {
      tableData.push([
        items[i].trim(),     // First column
        items[i + 1].trim(), // Second column
        items[i + 2].trim()  // Date column
      ]);
    }
  }
  
  const processedData = processTableData(tableData);
  currentTableData = processedData;
  originalRowCount = processedData.length;
  renderTable(processedData);
}

let matData = [];
let valueToCodes = {};
matData.forEach(([code, value]) => {
  if (!valueToCodes[value]) valueToCodes[value] = [];
  valueToCodes[value].push(code);
});

let matLookup = {};
matData.forEach(([code, value]) => {
  matLookup[code] = value;
});

let currentTableData = [];
let originalRowCount = 0;

function getColor(index) {
  const palette = [
    "#c9f1fc", "#d4f8c4", "#ffe0ac", "#f9c6c7", "#d6c6f9", "#ffc6e0",
    "#c6ffe0", "#f6f7d7", "#e6e6fa", "#cef6e3", "#ffd6d6", "#d6fffa"
  ];
  if (index < palette.length) return palette[index];
  return `hsl(${(index * 47) % 360}, 70%, 80%)`;
}

function removeContextMenu() {
  const menu = document.querySelector('.custom-context-menu');
  if (menu) menu.remove();
}

function removeDuplicateRows(tableData) {
  const uniqueRows = [];
  const seenRowSignatures = new Set();
  
  tableData.forEach(row => {
    const rowSignature = JSON.stringify(row);
    if (!seenRowSignatures.has(rowSignature)) {
      seenRowSignatures.add(rowSignature);
      uniqueRows.push(row);
    }
  });
  
  return uniqueRows;
}

function processTableData(rawTableData) {
  rawTableData.forEach(rowData => {
    if (rowData.length > 1) {
      const lookupValue = matLookup[rowData[1]];
      if (lookupValue !== undefined) {
        rowData[1] = lookupValue;
      }
    }
    
    if (rowData.length > 2 && rowData[2]) {
      const dateMatch = rowData[2].match(/^(\d{1,2})\.(\d{1,2})\.(\d{2,4})$/);
      if (dateMatch) {
        const [, day, month] = dateMatch;
        rowData[2] = `${day}.${month}.`;
      }
    }
  });
  
  return removeDuplicateRows(rawTableData);
}

function renderTable(tableData) {
  const valueCounts = {};
  tableData.forEach(row => {
    if (row.length > 1 && row[1]) {
      valueCounts[row[1]] = (valueCounts[row[1]] || 0) + 1;
    }
  });

  const frequentValues = Object.keys(valueCounts).filter(val => valueCounts[val] > 1);
  const valueColorMap = {};
  frequentValues.forEach((val, i) => {
    valueColorMap[val] = getColor(i);
  });

  const table = document.createElement('table');
  table.style.borderCollapse = 'collapse';

  tableData.forEach((rowData, rowIdx) => {
    const tr = document.createElement('tr');
    tr.dataset.rowIndex = rowIdx;
    
    rowData.forEach((cellData, colIdx) => {
      const td = document.createElement('td');
      const cleanedData = (cellData || '').split(/\r?\n/)[0];
      td.textContent = cleanedData;
      td.style.border = '1px solid #ccc';
      td.style.padding = '4px 8px';
      
      if (colIdx === 1 && valueColorMap[cleanedData]) {
        td.style.background = valueColorMap[cleanedData];
      }
      
      if (colIdx === 1) {
        td.addEventListener('contextmenu', function(e) {
          e.preventDefault();
          removeContextMenu();
          const codes = valueToCodes[cleanedData];
          if (!codes || codes.length === 0) return;
          const menu = document.createElement('div');
          menu.className = 'custom-context-menu';
          const ul = document.createElement('ul');
          codes.forEach(code => {
            const li = document.createElement('li');
            li.textContent = code;
            ul.appendChild(li);
          });
          menu.appendChild(ul);
          document.body.appendChild(menu);
          menu.style.left = `${e.pageX}px`;
          menu.style.top = `${e.pageY}px`;
        });
      } else {
        td.addEventListener('contextmenu', function(e) {
          e.preventDefault();
          removeContextMenu();
          tr.classList.toggle('selected-row');
        });
      }
      
      if (colIdx === 0) {
        td.addEventListener('click', function() {
          td.classList.toggle('highlight-first-col');
        });
      }
      tr.appendChild(td);
    });

    table.appendChild(tr);
  });
  
  const container = document.getElementById('tableContainer');
  container.innerHTML = '';
  container.appendChild(table);
}

document.addEventListener('click', removeContextMenu);
document.addEventListener('scroll', removeContextMenu);

document.addEventListener('keydown', function(e) {
  if (e.key === 'Delete') {
    const selectedRows = document.querySelectorAll('tr.selected-row');
    if (selectedRows.length > 0) {
      const indicesToDelete = [];
      selectedRows.forEach(row => {
        const idx = parseInt(row.dataset.rowIndex);
        if (!isNaN(idx)) {
          indicesToDelete.push(idx);
        }
      });
      
      indicesToDelete.sort((a, b) => b - a);
      
      indicesToDelete.forEach(rowIndex => {
        if (rowIndex >= 0 && rowIndex < currentTableData.length) {
          currentTableData.splice(rowIndex, 1);
        }
      });
      
      renderTable(currentTableData);
    }
  }
});
</script>

</html>